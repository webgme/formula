/*globals define, WebGMEGlobal*/
/*jshint browser: true*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Mon Nov 06 2017 13:29:33 GMT-0600 (CST).
 */

define([
    './FormulaCodeMirrorMode',
    'css!./styles/FormulaVizWidget.css'
], function (CodeMirror) {
    'use strict';

    var FormulaVizWidget,
        WIDGET_CLASS = 'formula-viz',
        SYNTAX_GUTTER = 'code-syntax';

    FormulaVizWidget = function (logger, container) {
        this._logger = logger.fork('Widget');

        this._el = container;
        this._segmentedDocument = {
            composition: [],
            segments: {}
        };
        this._wholeDocument = null;

        this._initialize();
        this._logger.debug('ctor finished');
    };

    FormulaVizWidget.prototype._initialize = function () {
        var self = this,
            saving = function () {
                self._save();
            };

        // set widget class
        this._el.addClass(WIDGET_CLASS);

        //handling the ctrl+S / cmd+S key pressing
        CodeMirror.commands.save = function (editor) {
            saving();
        };

        // The code editor.
        this.editor = CodeMirror(this._el[0], {
            lineNumbers: true,
            theme: 'monokai',
            matchBrackets: true,
            mode: {
                name: 'formula',
                globalVars: true
            },
            dragDrop: false,
            gutters: [SYNTAX_GUTTER, "CodeMirror-linenumbers"]
        });

        $(this.editor.getWrapperElement()).addClass('code-editor');
        this._wholeDocument = this.editor.getDoc();
        this._wholeDocument.on('beforeChange', function (doc, changeObj) {
            var markers = doc.findMarksAt(changeObj.from),
                i;
            for (i = 0; i < markers.length; i += 1) {
                if (markers[i].readonly) {
                    changeObj.cancel();
                }
            }
        });
        this._wholeDocument.on('change', function (/*doc,changeObj*/) {
            self._clearMarks();
        });
    };

    FormulaVizWidget.prototype.onWidgetContainerResize = function (width, height) {
        this._el.width(width);
        this._el.height(height);
        this.editor.refresh();
        this._logger.debug('Widget is resizing...');
    };

    /* * * * * * * * Complex document management services  * * * * */
    FormulaVizWidget.prototype.setDocumentSegment = function (segmentName, segmentValue) {
        if (this._segmentedDocument.segments[segmentName]) {
            this._segmentedDocument.segments[segmentName].value = segmentValue;
            this._rebuildCompleteDocument();
        } else {
            this._logger.error('unknown segment [' + segmentName + '] cannot be changed');
        }
    };

    FormulaVizWidget.prototype.setSegmentedDocument = function (segmentedDocumentObject) {
        // we do not have to worry about cleaning, as setting the main document allegedly does it
        var newDocument = {segments: {}},
            i;

        newDocument.composition = JSON.parse(JSON.stringify(segmentedDocumentObject.composition));

        if (Array.isArray(newDocument.composition) !== true) {
            this._logger.error('Invalid segmentedDocumentObject [should have a composition array tag]');
            return;
        }
        if (typeof segmentedDocumentObject.segments !== 'object' || segmentedDocumentObject.segments === null) {
            this._logger.error('Invalid segmentedDocumentObject ' +
                '[should have a segments tag that is the collection of the segments]');
            return;
        }

        for (i = 0; i < newDocument.composition.length; i += 1) {
            if (typeof newDocument.composition[i] !== 'string') {
                this._logger.error('Invalid segmentedDocumentObject [segment identification should be string based]');
                return;
            }

            if (segmentedDocumentObject.segments.hasOwnProperty(newDocument.composition[i]) !== true) {
                this._logger.error('Invalid segmentedDocumentObject [segment \'' +
                    newDocument.composition[i] + '\' is missing]');
                return;
            }

            if (segmentedDocumentObject.segments[newDocument.composition[i]].options &&
                typeof segmentedDocumentObject.segments[newDocument.composition[i]].options !== 'object') {
                this._logger.error('Invalid segmentedDocumentObject [segment \'' +
                    newDocument.composition[i] + '\' has an invalid options field]');
                return;
            }

            if (typeof segmentedDocumentObject.segments[newDocument.composition[i]].value !== 'string') {
                this._logger.error('All document segment value has to be a string.');
                return;
            }
            newDocument.segments[newDocument.composition[i]] = {
                options: JSON.parse(
                    JSON.stringify(segmentedDocumentObject.segments[newDocument.composition[i]].options || {})),
                value: segmentedDocumentObject.segments[newDocument.composition[i]].value
            };
        }

        this._segmentedDocument = newDocument;
        this._rebuildCompleteDocument();

    };

    FormulaVizWidget.prototype.getDocument = function () {
        return this._wholeDocument.getValue();
    };

    FormulaVizWidget.prototype.getDocumentSegment = function (segmentName) {
        if (this._segmentedDocument.segments[segmentName]) {
            return this._segmentedDocument.segments[segmentName].value;
        } else {
            this._logger.error('unknown segment [' + segmentName + ']');
            return null;
        }
    };

    FormulaVizWidget.prototype.getChangedSegments = function () {
        var segments = {},
            segment, doc;

        for (segment in this._segmentedDocument.segments) {
            doc = this._segmentedDocument.segments[segment].doc.getValue();
            if (doc !== this._segmentedDocument.segments[segment].value) {
                segments[segment] = doc;
            }
        }

        return segments;
    };

    FormulaVizWidget.prototype._getNumberOfLinesOfSegment = function (segmentName) {
        //TODO: check if this is enough or we need some more sophisticated thing
        return this._segmentedDocument.segments[segmentName].value.split('\n').length;
    };

    FormulaVizWidget.prototype._rebuildCompleteDocument = function () {
        var i, segment, wholeDocument = '',
            oldCursorPosition = this._wholeDocument.getCursor(),
            oldScrollInfo = this.editor.getScrollInfo(),
            lineIndex, segmentLines;

        this._clearMarks();
        for (i = 0; i < this._segmentedDocument.composition.length; i += 1) {
            segment = this._segmentedDocument.segments[this._segmentedDocument.composition[i]];
            if (segment.doc) {
                this._wholeDocument.unlinkDoc(segment.doc);
                delete segment.doc;
                if (segment.readOnlyMarker) {
                    segment.readOnlyMarker.clear();
                    delete segment.readOnlyMarker;
                }
            }
            wholeDocument += segment.value + '\n';
        }
        this._wholeDocument.setValue(wholeDocument);
        lineIndex = 0;
        for (i = 0; i < this._segmentedDocument.composition.length; i += 1) {
            segment = this._segmentedDocument.segments[this._segmentedDocument.composition[i]];
            segmentLines = this._getNumberOfLinesOfSegment(this._segmentedDocument.composition[i]);
            segment.doc = this._wholeDocument.linkedDoc({
                sharedHist: true,
                from: lineIndex,
                to: lineIndex + segmentLines
            });
            lineIndex += segmentLines;
            if (segment.options.readonly === true) {
                this._setSegmentReadOnly(this._segmentedDocument.composition[i], true);
            }
        }

        this.editor.focus();
        this.editor.refresh();
        this._wholeDocument.setCursor(oldCursorPosition);
        this.editor.scrollTo(oldScrollInfo.left, oldScrollInfo.top);
    };

    FormulaVizWidget.prototype._setSegmentReadOnly = function (segmentName, readOnly) {
        var segmentInfo,
            fromLine,
            toLine;
        if (this._segmentedDocument.segments[segmentName]) {
            segmentInfo = this._segmentedDocument.segments[segmentName];
            if (segmentInfo.readOnlyMarker) {
                segmentInfo.readOnlyMarker.clear();
                delete segmentInfo.readOnlyMarker;
            }

            if (readOnly) {
                fromLine = segmentInfo.doc.firstLine();
                toLine = segmentInfo.doc.lastLine();

                segmentInfo.readOnlyMarker = this._wholeDocument.markText(
                    {line: fromLine, ch: 0},
                    {line: toLine, ch: 0},
                    {
                        readonly: true,
                        atomic: false,
                        inclusiveLeft: true,
                        inclusiveRight: false,
                        className: 'read-only-code'
                    }
                );
            }
        } else {
            this._logger.error('unknown segment [' + segmentName + '] cannot be changed');
        }
    };

    FormulaVizWidget.prototype._save = function () {
        var changedSegments = this.getChangedSegments(),
            segment;

        if (Object.keys(changedSegments).length > 0) {
            for (segment in changedSegments) {
                this._segmentedDocument.segments[segment].value = changedSegments[segment];
            }

            this.onSave(changedSegments);
        }
    };

    /* * * * * * * * Document marking services  * * * * */
    FormulaVizWidget.prototype._clearMarks = function () {
        this.editor.clearGutter(SYNTAX_GUTTER);
        this.onClearMarks();
        this.editor.refresh();
    };

    FormulaVizWidget.prototype.markErrors = function (errors) {
        var i, marker;
        this._clearMarks();
        for (i = 0; i < errors.length; i += 1) {
            marker = document.createElement('i');
            marker.className = 'glyphicon glyphicon-exclamation-sign';
            marker.style.color = '#822';
            marker.title = errors[i].text;
            this.editor.setGutterMarker(Number(errors[i].line)-1, SYNTAX_GUTTER, marker);
        }
        // this.editor.focus();
        // this.editor.refresh();
    };

    FormulaVizWidget.prototype.setConformance = function (conformance) {

    };
    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    FormulaVizWidget.prototype.destroy = function () {
    };

    FormulaVizWidget.prototype.onActivate = function () {
        this._logger.debug('FormulaVizWidget has been activated');
    };

    FormulaVizWidget.prototype.onDeactivate = function () {
        this._logger.debug('FormulaVizWidget has been deactivated');
    };

    return FormulaVizWidget;
});
